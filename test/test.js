const chai = require("chai");

const { expect } = chai;

let treasure;
let owner;
let addr1;
let addr2;
let attack;

// Start test block
describe("Treasure", function () {
  before(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    const Treasure = await ethers.getContractFactory("Treasure");
    treasure = await upgrades.deployProxy(Treasure, [], { initializer: "initialize" });
    await treasure.deployed();
  });

  it("Treasure is deployed correctly", async function () {
    expect((await treasure.name()).toString()).to.equal("Treasure");
    expect((await treasure.symbol()).toString()).to.equal("TREASURE");
  });

  it("Should mint tokens by the owner", async function () {
    await treasure.mint(addr1.address, ethers.utils.parseEther("100"));

    const balance = await treasure.balanceOf(addr1.address);
    expect(balance).to.be.equal(ethers.utils.parseEther("100"));
  });

  it("Should not allow minting by non-owner", async function () {
    await expect(treasure.connect(addr1).mint(addr2.address, ethers.utils.parseEther("100"))).to.be.revertedWith("Ownable: caller is not the owner");
  });

  it("Deposit works", async function () {
    await treasure.connect(addr1).deposit({ value: ethers.utils.parseEther("1") });
    expect(await treasure.getDepositBalance(addr1.address)).to.be.equal(ethers.utils.parseEther("1"));
  });

  it("Withdraw works", async function () {
    await treasure.connect(addr1).withdrawAll();
    expect(await treasure.getDepositBalance(addr1.address)).to.be.equal(0);
  });
});

describe("Reentrancy Vulnerability", function () {
  before(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    const Treasure = await ethers.getContractFactory("Treasure");
    treasure = await upgrades.deployProxy(Treasure, [], { initializer: "initialize" });
    await treasure.deployed();

    const Attack = await ethers.getContractFactory("Attack");
    attack = await Attack.deploy(treasure.address);
    await attack.deployed();
  });

  it("Attack withdraw with vulnerability", async function () {
    await treasure.connect(addr1).deposit({ value: ethers.utils.parseEther("50") });
    await attack.attack({ value: ethers.utils.parseEther("1") });
    expect(await ethers.provider.getBalance(attack.address)).to.be.equal(ethers.utils.parseEther("51"));
  });

  it("Upgrade to V2 and the Attack fails.", async function () {
    const TreasureV2 = await ethers.getContractFactory("TreasureV2");
    await upgrades.upgradeProxy(treasure.address, TreasureV2);
    console.log("Treasure upgraded to V2");

    await treasure.connect(addr1).deposit({ value: ethers.utils.parseEther("50") });
    await expect(attack.attack({ value: ethers.utils.parseEther("1") })).to.be.reverted;
  });
});
